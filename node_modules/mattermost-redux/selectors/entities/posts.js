'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getSearchResults = exports.getPostsInCurrentChannel = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See License.txt for license information.

exports.getAllPosts = getAllPosts;
exports.getPost = getPost;
exports.getReactionsForPosts = getReactionsForPosts;
exports.makeGetReactionsForPost = makeGetReactionsForPost;
exports.getOpenGraphMetadata = getOpenGraphMetadata;
exports.getOpenGraphMetadataForUrl = getOpenGraphMetadataForUrl;
exports.makeGetPostsInChannel = makeGetPostsInChannel;
exports.makeGetPostsAroundPost = makeGetPostsAroundPost;
exports.makeGetPostsForThread = makeGetPostsForThread;
exports.makeGetCommentCountForPost = makeGetCommentCountForPost;

var _reselect = require('reselect');

var _preferences = require('./preferences');

var _users = require('./users');

var _constants = require('../../constants');

var _post_utils = require('../../utils/post_utils');

var _preference_utils = require('../../utils/preference_utils');

function getAllPosts(state) {
    return state.entities.posts.posts;
}

function getPost(state, postId) {
    return getAllPosts(state)[postId];
}

function getReactionsForPosts(state) {
    return state.entities.posts.reactions;
}

function makeGetReactionsForPost() {
    return (0, _reselect.createSelector)(getReactionsForPosts, function (state, postId) {
        return postId;
    }, function (reactions, postId) {
        return Object.values(reactions[postId] || {});
    });
}

function getOpenGraphMetadata(state) {
    return state.entities.posts.openGraph;
}

function getOpenGraphMetadataForUrl(state, url) {
    return state.entities.posts.openGraph[url];
}

function getPostIdsInCurrentChannel(state) {
    return state.entities.posts.postsInChannel[state.entities.channels.currentChannelId] || [];
}

var getPostsInCurrentChannel = exports.getPostsInCurrentChannel = (0, _reselect.createSelector)(getAllPosts, getPostIdsInCurrentChannel, function (posts, postIds) {
    return postIds.map(function (id) {
        return posts[id];
    });
});

function formatPostInChannel(post, previousPost, index, allPosts, postIds, currentUser) {
    var isFirstReply = false;
    var isLastReply = false;
    var commentedOnPost = void 0;

    if (post.root_id) {
        if (previousPost.root_id !== post.root_id) {
            // Post is the first reply in a list of consecutive replies
            isFirstReply = true;

            if (previousPost.id !== post.root_id) {
                commentedOnPost = allPosts[post.root_id];
            }
        }

        if (index - 1 < 0 || allPosts[postIds[index - 1]].root_id !== post.root_id) {
            // Post is the last reply in a list of consecutive replies
            isLastReply = true;
        }
    }

    var previousPostIsComment = false;
    if (previousPost.root_id) {
        previousPostIsComment = true;
    }

    var postFromWebhook = Boolean(post.props && post.props.from_webhook);
    var prevPostFromWebhook = Boolean(previousPost.props && previousPost.props.from_webhook);
    var consecutivePostByUser = false;
    if (previousPost.user_id === post.user_id && post.create_at - previousPost.create_at <= _constants.Posts.POST_COLLAPSE_TIMEOUT && !postFromWebhook && !prevPostFromWebhook && !(0, _post_utils.isSystemMessage)(post) && !(0, _post_utils.isSystemMessage)(previousPost)) {
        // The last post and this post were made by the same user within some time
        consecutivePostByUser = true;
    }

    var replyCount = 0;
    var threadRepliedToByCurrentUser = false;
    var threadCreatedByCurrentUser = false;
    var rootId = post.root_id || post.id;
    postIds.forEach(function (pid) {
        var p = allPosts[pid];
        if (p.root_id === rootId) {
            replyCount += 1;

            if (p.user_id === currentUser.id) {
                threadRepliedToByCurrentUser = true;
            }
        }

        if (p.id === rootId && p.user_id === currentUser.id) {
            threadCreatedByCurrentUser = true;
        }
    });

    var isCommentMention = false;
    var commentsNotifyLevel = 'never';
    if (currentUser && currentUser.notify_props && currentUser.notify_props.comments) {
        commentsNotifyLevel = currentUser.notify_props.comments;
    }

    var notCurrentUser = post.user_id !== currentUser.id || post.props && post.props.from_webhook;
    if (notCurrentUser) {
        if (commentsNotifyLevel === 'any' && (threadCreatedByCurrentUser || threadRepliedToByCurrentUser)) {
            isCommentMention = true;
        } else if (commentsNotifyLevel === 'root' && threadCreatedByCurrentUser) {
            isCommentMention = true;
        }
    }

    return _extends({}, post, {
        isFirstReply: isFirstReply,
        isLastReply: isLastReply,
        previousPostIsComment: previousPostIsComment,
        commentedOnPost: commentedOnPost,
        consecutivePostByUser: consecutivePostByUser,
        replyCount: replyCount,
        isCommentMention: isCommentMention
    });
}

function makeGetPostsInChannel() {
    return (0, _reselect.createSelector)(getAllPosts, function (state, channelId) {
        return state.entities.posts.postsInChannel[channelId];
    }, _users.getCurrentUser, _preferences.getMyPreferences, function (allPosts, postIds, currentUser, myPreferences) {
        if (!postIds) {
            return null;
        }

        var posts = [];

        var joinLeavePref = myPreferences[(0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_ADVANCED_SETTINGS, 'join_leave')];
        var filterJoinLeave = joinLeavePref ? joinLeavePref.value === 'false' : false;

        for (var i = 0; i < postIds.length; i++) {
            var post = allPosts[postIds[i]];
            if (!(0, _post_utils.shouldFilterPost)(post, { filterJoinLeave: filterJoinLeave })) {
                var previousPost = allPosts[postIds[i + 1]] || { create_at: 0 };
                posts.push(formatPostInChannel(post, previousPost, i, allPosts, postIds, currentUser));
            }
        }

        return posts;
    });
}

function makeGetPostsAroundPost() {
    return (0, _reselect.createSelector)(getAllPosts, function (state, postId, channelId) {
        return state.entities.posts.postsInChannel[channelId];
    }, function (state, postId) {
        return postId;
    }, _users.getCurrentUser, _preferences.getMyPreferences, function (allPosts, postIds, focusedPostId, currentUser, myPreferences) {
        if (!postIds) {
            return null;
        }

        var focusedPostIndex = postIds.indexOf(focusedPostId);
        if (focusedPostIndex === -1) {
            return null;
        }

        var desiredPostIndexBefore = focusedPostIndex - _constants.Posts.POST_CHUNK_SIZE / 2;
        var minPostIndex = desiredPostIndexBefore < 0 ? 0 : desiredPostIndexBefore;

        var slicedPostIds = postIds.slice(minPostIndex);

        var posts = [];
        var joinLeavePref = myPreferences[(0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_ADVANCED_SETTINGS, 'join_leave')];
        var filterJoinLeave = joinLeavePref ? joinLeavePref.value === 'false' : false;

        for (var i = 0; i < slicedPostIds.length; i++) {
            var post = allPosts[slicedPostIds[i]];
            if (!(0, _post_utils.shouldFilterPost)(post, { filterJoinLeave: filterJoinLeave })) {
                var previousPost = allPosts[slicedPostIds[i + 1]] || { create_at: 0 };
                var formattedPost = formatPostInChannel(post, previousPost, i, allPosts, slicedPostIds, currentUser);

                if (post.id === focusedPostId) {
                    formattedPost.highlight = true;
                }

                posts.push(formattedPost);
            }
        }

        return posts;
    });
}

// Returns a function that creates a creates a selector that will get the posts for a given thread.
// That selector will take a props object (containing a channelId field and a rootId field) as its
// only argument and will be memoized based on that argument.
function makeGetPostsForThread() {
    return (0, _reselect.createSelector)(getAllPosts, function (state, props) {
        return state.entities.posts.postsInChannel[props.channelId];
    }, function (state, props) {
        return props;
    }, function (posts, postIds, _ref) {
        var rootId = _ref.rootId;

        var thread = [];

        if (postIds) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = postIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var id = _step.value;

                    var post = posts[id];

                    if (id === rootId || post.root_id === rootId) {
                        thread.push(post);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }

        return thread;
    });
}

function makeGetCommentCountForPost() {
    return (0, _reselect.createSelector)(getAllPosts, function (state, props) {
        return props;
    }, function (posts, _ref2) {
        var currentPost = _ref2.post;

        var count = 0;
        for (var id in posts) {
            if (posts.hasOwnProperty(id)) {
                var post = posts[id];

                if (post.root_id === currentPost.id && post.state !== _constants.Posts.POST_DELETED) {
                    count += 1;
                }
            }
        }

        return count;
    });
}

var getSearchResults = exports.getSearchResults = (0, _reselect.createSelector)(getAllPosts, function (state) {
    return state.entities.search.results;
}, function (posts, postIds) {
    return postIds.map(function (id) {
        return posts[id];
    });
});