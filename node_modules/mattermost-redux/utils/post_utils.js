'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addDatesToPostList = addDatesToPostList;
exports.isPostFlagged = isPostFlagged;
exports.isSystemMessage = isSystemMessage;
exports.isFromWebhook = isFromWebhook;
exports.isPostEphemeral = isPostEphemeral;
exports.shouldIgnorePost = shouldIgnorePost;
exports.isPostOwner = isPostOwner;
exports.isEdited = isEdited;
exports.canDeletePost = canDeletePost;
exports.canEditPost = canEditPost;
exports.getLastCreateAt = getLastCreateAt;
exports.shouldFilterPost = shouldFilterPost;
exports.isPostPendingOrFailed = isPostPendingOrFailed;

var _constants = require('../constants');

var _preference_utils = require('./preference_utils');

// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See License.txt for license information.

function addDatesToPostList(posts) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var indicateNewMessages = options.indicateNewMessages,
        currentUserId = options.currentUserId,
        lastViewedAt = options.lastViewedAt;


    var out = [];

    var lastDate = null;
    var subsequentPostIsUnread = false;
    var subsequentPostUserId = void 0;
    var postIsUnread = void 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = posts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var post = _step.value;

            if (post.state === _constants.Posts.POST_DELETED && post.user_id === currentUserId) {
                continue;
            }
            postIsUnread = post.create_at > lastViewedAt;
            if (indicateNewMessages && subsequentPostIsUnread && !postIsUnread && subsequentPostUserId !== currentUserId) {
                out.push(_constants.General.START_OF_NEW_MESSAGES);
            }
            subsequentPostIsUnread = postIsUnread;
            subsequentPostUserId = post.user_id;

            var postDate = new Date(post.create_at);

            // Push on a date header if the last post was on a different day than the current one
            if (lastDate && lastDate.toDateString() !== postDate.toDateString()) {
                out.push(lastDate);
            }

            lastDate = postDate;
            out.push(post);
        }

        // Push on the date header for the oldest post
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    if (lastDate) {
        out.push(lastDate);
    }

    return out;
}

function isPostFlagged(postId, myPreferences) {
    var key = (0, _preference_utils.getPreferenceKey)(_constants.Preferences.CATEGORY_FLAGGED_POST, postId);
    return myPreferences.hasOwnProperty(key);
}

function isSystemMessage(post) {
    return post.type !== '' && post.type && post.type.startsWith(_constants.Posts.SYSTEM_MESSAGE_PREFIX);
}

function isFromWebhook(post) {
    return post.props && post.props.from_webhook;
}

function isPostEphemeral(post) {
    return post.type === _constants.Posts.POST_TYPES.EPHEMERAL || post.state === _constants.Posts.POST_DELETED;
}

function shouldIgnorePost(post) {
    return _constants.Posts.IGNORE_POST_TYPES.includes(post.type);
}

function isPostOwner(userId, post) {
    return userId === post.user_id;
}

function isEdited(post) {
    return post.edit_at > 0;
}

function canDeletePost(config, license, userId, post, isAdmin, isSystemAdmin) {
    var isOwner = isPostOwner(userId, post);

    if (license.IsLicensed === 'true') {
        return config.RestrictPostDelete === _constants.General.PERMISSIONS_ALL && (isOwner || isAdmin) || config.RestrictPostDelete === _constants.General.PERMISSIONS_TEAM_ADMIN && isAdmin || config.RestrictPostDelete === _constants.General.PERMISSIONS_SYSTEM_ADMIN && isSystemAdmin;
    }
    return isOwner || isAdmin;
}

function canEditPost(config, license, userId, post, editDisableAction) {
    var isOwner = isPostOwner(userId, post);
    var canEdit = isOwner && !isSystemMessage(post);

    if (canEdit && license.IsLicensed === 'true') {
        if (config.AllowEditPost === _constants.General.ALLOW_EDIT_POST_NEVER) {
            canEdit = false;
        } else if (config.AllowEditPost === _constants.General.ALLOW_EDIT_POST_TIME_LIMIT) {
            var timeLeft = post.create_at + config.PostEditTimeLimit * 1000 - Date.now();
            if (timeLeft > 0) {
                editDisableAction.fireAfter(timeLeft + 1000);
            } else {
                canEdit = false;
            }
        }
    }
    return canEdit;
}

function getLastCreateAt(postsArray) {
    var createAt = postsArray.map(function (p) {
        return p.create_at;
    });

    if (createAt.length) {
        return Reflect.apply(Math.max, null, createAt);
    }

    return 0;
}

function shouldFilterPost(post) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    // Add as much filters as needed here, if you want to filter the post return true
    var postTypes = _constants.Posts.POST_TYPES;

    if (options.filterJoinLeave) {
        var joinLeaveTypes = [postTypes.JOIN_LEAVE, postTypes.JOIN_CHANNEL, postTypes.LEAVE_CHANNEL, postTypes.ADD_REMOVE, postTypes.ADD_TO_CHANNEL, postTypes.REMOVE_FROM_CHANNEL];
        if (joinLeaveTypes.includes(post.type)) {
            return true;
        }
    }

    return false;
}

function isPostPendingOrFailed(post) {
    return post.failed || post.id === post.pending_post_id;
}